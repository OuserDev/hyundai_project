---
- name: 진단 및 조치 - PHP expose_php 옵션 설정
  hosts: PostWebServers
  become: yes
  gather_facts: yes

  # 1. 변수 정의
  vars:
    # --- 보고서 관련 ---
    playbook_name: "1_6_3_php_allow_url.yml"
    result_json_path: "/tmp/security_report_php_allow_url_option.json"
    remediation_tasks_performed: []
  
  tasks:
    # 2. 진단
    # PHP 설치 여부 확인
    - name: PHP 설치 여부 확인
      ansible.builtin.command: which php
      register: php_installed
      failed_when: false
      changed_when: false

    # PHP 미설치 시 종료
    - name: PHP 미설치 시 종료
      ansible.builtin.fail:
        msg: "PHP가 설치되어 있지 않습니다. 설치 후 다시 실행해주세요."
      when: php_installed.rc != 0
        
    # PHP 설정파일 조회
    - name: PHP 설정파일 조회
      ansible.builtin.shell: "find /etc/php -name php.ini 2>/dev/null || find /etc -name php.ini 2>/dev/null | head -5"
      register: php_ini_files
      changed_when: false

    # 각 php.ini에서 allow_url_fopen 값 찾기
    - name: 각 php.ini에서 allow_url_fopen 값 찾기
      ansible.builtin.shell: "grep '^\\s*allow_url_fopen\\s*=' {{ item }} || echo 'allow_url_fopen = (설정없음)'"
      loop: "{{ php_ini_files.stdout_lines }}"
      register: allow_url_fopen_results
      changed_when: false
      when: php_ini_files.stdout_lines | length > 0

    # 취약한 설정 파일 목록 생성
    - name: 취약한 설정 파일 목록 생성
      ansible.builtin.set_fact:
        vulnerable_files: >-
          {%- set v_files = [] -%}
          {%- for res in allow_url_fopen_results.results | default([]) -%}
            {%- if res.stdout is defined and 'On' in res.stdout or 'on' in res.stdout or '= 1' in res.stdout -%}
              {%- set _ = v_files.append({'file': res.item, 'current_setting': res.stdout.strip()}) -%}
            {%- endif -%}
          {%- endfor -%}
          {{ v_files }}

    # 최종 취약 여부 판단
    - name: 취약 여부 종합 판단
      ansible.builtin.set_fact:
        is_vulnerable: "{{ vulnerable_files | length > 0 }}"
        report_timestamp: "{{ ansible_date_time.iso8601 }}"

    # 3. 진단 결과 보고
    # 진단 결과를 콘솔에 간단히 출력
    - name: 진단 결과 콘솔 출력
      ansible.builtin.debug:
        msg: "진단결과: {% if is_vulnerable %}취약 (allow_url_fopen가 On으로 설정된 파일 {{ vulnerable_files | length }}개 발견){% else %}양호{% endif %}"

    # 초기 JSON 보고서 데이터 생성 및 저장
    - name: 초기 JSON 보고서 생성 및 저장
      ansible.builtin.copy:
        content: |
          {{
            {
              "playbook_name": playbook_name,
              "task_description": "PHP allow_url_fopen 옵션 설정",
              "diagnosis_result": "취약" if is_vulnerable else "양호",
              "is_vulnerable": is_vulnerable,
              "timestamp": report_timestamp,
              "hostname": inventory_hostname,
              "vulnerability_details": {
                "reason": "PHP의 allow_url_fopen 옵션이 On으로 설정되어 있어 에러 정보가 노출될 수 있습니다." if is_vulnerable else "PHP의 allow_url_fopen 옵션이 안전하게 설정되어 있습니다.",
                "vulnerable_files_found": vulnerable_files,
                "recommendation": "allow_url_fopen = Off로 설정하여 에러 정보 노출을 방지해야 합니다."
              }
            } | to_nice_json
          }}
        dest: "{{ result_json_path }}"
        mode: '0644'
      delegate_to: localhost
      become: false

    # 4. 조치
    # display_errors On → Off 변경
    - name: display_errors On → Off 변경
      ansible.builtin.lineinfile:
        path: "{{ item.file }}"
        regexp: '^\s*allow_url_fopen\s*=\s*(On|on|1)\b'
        line: 'allow_url_fopen = Off'
        backrefs: yes
        backup: yes
      loop: "{{ vulnerable_files }}"
      register: allow_url_fopen_changes
      when: is_vulnerable
      notify: Reload PHP-FPM

    # 5. 조치 결과 보고
    # 수행된 조치 작업 기록
    - name: 수행된 조치 작업 기록
      ansible.builtin.set_fact:
        remediation_done: "{{ allow_url_fopen_changes.changed | default(false) }}"
        remediation_tasks_performed: "{{ ['PHP 설정 파일 수정'] if allow_url_fopen_changes.changed | default(false) else [] }}"
        modified_files: "{{ allow_url_fopen_changes.results | selectattr('changed', 'equalto', true) | map(attribute='item.file') | list }}"
      when: is_vulnerable

    # 조치 결과를 콘솔에 출력
    - name: 조치 결과 콘솔 출력
      ansible.builtin.debug:
        msg: |
          총괄 조치 결과: {% if remediation_done | default(false) %}조치 완료{% elif not is_vulnerable %}조치 불필요 (양호){% else %}조치 실패{% endif %}
          ===== DISPLAY_ERRORS 조치 완료 파일 목록 =====
          {% for file in modified_files | default([]) %}
          - {{ file }}
          {% else %}
          변경된 파일이 없습니다.
          {% endfor %}
          =========================================
      when: not ansible_check_mode

    # 최종 JSON 보고서에 조치 결과 추가 및 저장
    - name: 최종 JSON 보고서에 조치 결과 추가 및 저장
      ansible.builtin.copy:
        content: |
          {{
            (lookup('file', result_json_path) | from_json) | combine({
              'remediation_applied': remediation_done | default(false),
              'remediation_result': '조치 완료' if (remediation_done | default(false)) else ('조치 불필요' if not is_vulnerable else '조치 실패'),
              'remediation_timestamp': report_timestamp,
              'remediation_tasks_performed': remediation_tasks_performed | default([]),
              'modified_files': modified_files | default([])
            }, recursive=True) | to_nice_json
          }}
        dest: "{{ result_json_path }}"
        mode: '0644'
      delegate_to: localhost
      become: false
      when: not ansible_check_mode and is_vulnerable

  # 핸들러
  handlers:
    - name: Reload PHP-FPM
      ansible.builtin.service:
        name: "php{{ (item.split('/')[3] if item is match('.*php/\\d+\\.\\d+/.*') else 'fpm') }}-fpm"
        state: reloaded
      loop: "{{ php_ini_files.stdout_lines }}"
      when: item | regex_search('fpm')