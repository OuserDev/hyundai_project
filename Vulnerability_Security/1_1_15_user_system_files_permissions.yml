---
- name: 사용자, 시스템 시작파일, 환경파일 소유자 및 권한 설정 점검 및 조치
  hosts: localhost # 이 플레이북을 실행할 대상 호스트
  become: yes # 시스템 파일 및 사용자 홈 디렉터리 접근을 위해 root 권한이 필요합니다.

  vars:
    # 점검할 사용자별 환경/시작 파일 목록
    # 이 파일들은 각 사용자의 홈 디렉터리 아래에 있을 것으로 예상됩니다.
    # 일반적으로 숨김 파일이므로 '.'으로 시작합니다.
    user_env_files:
      - .bashrc
      - .profile
      - .bash_profile
      - .bash_logout
      - .cshrc
      - .login
      - .kshrc
      - .tcshrc
      - .zshrc
      - .zprofile
      - .zlogout
      - .vimrc
      # 필요에 따라 다른 사용자 환경 파일을 추가할 수 있습니다.

    # 권한 점검 시 제외할 시스템 계정 UID (예: 시스템 계정은 홈 디렉터리가 없거나, 특정 권한이 필요한 경우가 있습니다)
    # 0은 root, 65534는 nobody/nfsnobody 등 일반적으로 시스템에서 사용되는 UID입니다.
    # UID 1000 미만은 보통 시스템 계정으로 간주됩니다.
    excluded_uids:
      - 0    # root 사용자
      - 65534 # nobody (NFS 관련 등으로 사용될 수 있음)
      # 추가적으로 제외할 시스템 계정 UID가 있다면 여기에 추가하세요.

  tasks:
    - name: "시스템의 모든 사용자 정보 가져오기"
      # /etc/passwd 파일을 읽어 사용자 목록과 홈 디렉터리 정보를 파싱합니다.
      # shell 모듈 사용 시 파싱 오류를 줄이기 위해 `getent passwd` 사용을 권장합니다.
      ansible.builtin.command: getent passwd
      register: passwd_output
      changed_when: false # 이 태스크는 시스템을 변경하지 않으므로 변경 없음으로 표시

    - name: "일반 사용자 홈 디렉터리 목록 생성"
      # passwd_output에서 각 사용자의 홈 디렉터리 경로와 UID/GID를 추출합니다.
      # excluded_uids에 포함되지 않고 홈 디렉터리가 있는 사용자만 필터링합니다.
      ansible.builtin.set_fact:
        users_with_homes: |
          {% set user_list = [] %}
          {% for line in passwd_output.stdout_lines %}
            {% set parts = line.split(':') %}
            {% set username = parts[0] %}
            {% set uid = parts[2] | int %}
            {% set gid = parts[3] | int %}
            {% set home_dir = parts[5] %}
            {% if home_dir and home_dir != '/' and uid >= 1000 and uid not in excluded_uids %} # UID 1000 이상인 일반 사용자 필터링
              {% set _ = user_list.append({'name': username, 'home': home_dir, 'uid': uid, 'gid': gid}) %}
            {% endif %}
          {% endfor %}
          {{ user_list }}
      changed_when: false # 이 태스크는 팩트를 설정하므로 변경 없음으로 표시

    - name: "각 사용자 홈 디렉터리 내 환경 파일 점검 및 권한/소유자 수집"
      # `users_with_homes` 목록과 `user_env_files` 목록을 조합하여 각 파일의 stat 정보를 가져옵니다.
      ansible.builtin.stat:
        path: "{{ item[0].home }}/{{ item[1] }}"
      register: env_file_stats
      loop: "{{ users_with_homes | product(user_env_files) | list }}" # 사용자-파일 조합을 위한 nested loop
      loop_control:
        label: "{{ item[0].name }}:{{ item[0].home }}/{{ item[1] }}" # 사용자/파일 경로로 레이블 설정
      when: users_with_homes is defined and users_with_homes | length > 0 # 사용자 목록이 비어있지 않을 때만 실행

    - name: "SUID/SGID 취약점과 유사하게, 취약한 환경 파일 목록 생성"
      # 진단 결과를 출력하기 위해 취약한 파일들만 모아둘 리스트 변수를 초기화하고 채웁니다.
      ansible.builtin.set_fact:
        vulnerable_env_files: []

    - name: "취약한 환경 파일 목록에 파일 추가"
      ansible.builtin.set_fact:
        vulnerable_env_files: "{{ vulnerable_env_files + [
          {
            'user': item[0].name,
            'path': item[1], # 환경 파일 이름 (예: .bashrc)
            'full_path': item[0].home + '/' + item[1], # 전체 경로
            'expected_owner': item[0].name, # 예상되는 소유자 (해당 사용자)
            'actual_owner': item.stat.pw_name, # 실제 소유자
            'expected_mode': '0644', # 예상되는 권한
            'actual_mode': item.stat.mode | oct # 실제 권한 (8진수)
          }
        ] }}"
      loop: "{{ env_file_stats.results }}" # `stat` 결과 리스트를 순회합니다.
      loop_control:
        label: "{{ item.item[0].name }}:{{ item.item[0].home }}/{{ item.item[1] }}" # 실제 item의 구조를 반영하여 레이블 설정
      when:
        # 파일이 실제로 존재하고, 접근 가능한 경우에만 평가합니다.
        - item.stat is defined and item.stat.exists and item.stat.isreg # 일반 파일인지 확인
        # 소유자가 root도 아니고 해당 사용자도 아닌 경우 OR
        - (item.stat.pw_name != item.item[0].name and item.stat.pw_name != 'root') or
        # 권한이 644(-rw-r--r--)가 아닌 경우 (sticky bit, SUID, SGID는 포함하지 않는 순수 권한만 644)
        - (item.stat.mode | int != 0o644)
        # `item.item[0]`은 사용자 정보 딕셔너리, `item.item[1]`은 환경 파일 이름입니다.

    - name: "환경 파일 점검 진단 결과 출력"
      ansible.builtin.debug:
        msg: |
          {% if vulnerable_env_files | length > 0 %}
            <진단 결과: 취약>
            다음 사용자 환경/시작 파일들의 소유자 또는 권한 설정이 기준에 부합하지 않습니다.
            세부 정보:
            {% for file_info in vulnerable_env_files %}
              - 사용자: {{ file_info.user }}
                파일 경로: {{ file_info.full_path }}
                예상 소유자: {{ file_info.expected_owner }} (또는 root)
                실제 소유자: {{ file_info.actual_owner }}
                예상 권한: {{ file_info.expected_mode }}
                실제 권한: {{ file_info.actual_mode }}
            {% endfor %}
            조치 권고: 위에 나열된 파일들의 소유자를 해당 계정 또는 root로, 권한을 644(-rw-r--r--)로 변경하십시오.
          {% else %}
            <진단 결과: 양호>
            모든 사용자 환경/시작 파일들의 소유자 및 권한이 기준에 부합합니다.
          {% endif %}
      when: vulnerable_env_files is defined # 결과가 있을 때만 출력

    # --- 조치: 취약 파일의 소유자 및 권한 변경 (선택 사항) ---
    # 이 조치는 `--check` 옵션 없이 실행될 때만 실제로 적용됩니다.
    # 반드시 사전 검토와 테스트 후에 적용해야 합니다.
    - name: "취약한 환경 파일의 소유자 및 권한 설정 (조치)"
      ansible.builtin.file:
        path: "{{ item.full_path }}"
        owner: "{{ item.expected_owner }}" # 해당 사용자 계정으로 소유자 변경
        group: "{{ item.expected_owner }}" # 해당 사용자 계정의 주 그룹으로 그룹 변경
        mode: '0644' # 권한을 rw-r--r-- (644)로 변경
      loop: "{{ vulnerable_env_files }}" # 취약한 파일 목록을 순회
      loop_control:
        label: "{{ item.full_path }}"
      when:
        - vulnerable_env_files is defined and vulnerable_env_files | length > 0
        - item.full_path is defined # 경로가 유효한지 확인 (혹시 모를 오류 방지)
      # 실제 변경이 발생할 때만 태스크를 보고하도록 `changed_when`를 설정할 수도 있습니다.
      # changed_when: false # 조치가 변경을 일으킬 수 있으므로 변경됨으로 표시하는 것이 일반적입니다.
